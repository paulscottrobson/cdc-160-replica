// *******************************************************************************************************************************
// *******************************************************************************************************************************
//
//		Name:		sys_processor.cpp
//		Purpose:	Processor Emulation.
//		Created:	26th October 2015
//		Author:		Paul Robson (paul@robsons.org.uk)
//
// *******************************************************************************************************************************
// *******************************************************************************************************************************

#include <stdio.h>
#include "sys_processor.h"
#include "hardware.h"

// *******************************************************************************************************************************
//														Main Memory/CPU
// *******************************************************************************************************************************

static WORD16 memory[4096];													// RAM memory
static WORD16 s,a,p,z,cycles;
static BYTE8 ioMode,ioOpcode,halt;

// *******************************************************************************************************************************
//													Memory read and write macros.
// *******************************************************************************************************************************

#define read() 		z = memory[s]
#define write() 	memory[s] = z

// *******************************************************************************************************************************
//														I/O Port connections
// *******************************************************************************************************************************

#include "_cdc160_support.h"

// *******************************************************************************************************************************
//													  Port interfaces
// *******************************************************************************************************************************

#define WRITE(a,d) memory[a] = d

void CPUReset(void) {
	p = a = z = halt = 0;
	ioOpcode = ioMode = 0;
	restart();
	HWIReset();

	WRITE(0001,0406);
	WRITE(0002,0603);
}

// *******************************************************************************************************************************
//													 Execute a single phase.
// *******************************************************************************************************************************

#include <stdlib.h>
#include <stdio.h>

BYTE8 CPUExecuteInstruction(void) {
	if (halt == 0) {																// CPU is running (not halt)		
		switch(z >> 6) {															// Do the selected opcode and phase.
			#include "_cdc160_case.h"
		}
	}	
	if (halt == 0 && cycles < CYCLES_PER_FRAME) return 0;							// Frame in progress, return 0.
	cycles -= CYCLES_PER_FRAME;														// Adjust cycle counter
	if (halt != 0) cycles = 0;														// Fix up for halt.
	HWIEndFrame();																	// Hardware stuff.
	return FRAME_RATE;																// Return the frame rate for sync speed.
}

#ifdef INCLUDE_DEBUGGING_SUPPORT

// *******************************************************************************************************************************
//										 Get the step over breakpoint value
// *******************************************************************************************************************************

WORD16 CPUGetStepOverBreakpoint(void) {
	return 0xFFFF;
}

// *******************************************************************************************************************************
//										Run continuously till breakpoints / halt.
// *******************************************************************************************************************************

BYTE8 CPUExecute(WORD16 break1,WORD16 break2) {
	BYTE8 rate = 0;
	while(1) {
		rate = CPUExecuteInstruction();												// Execute one instruction phase.
		if (rate != 0) {															// If end of frame, return rate.
			return rate;													
		}
		if (p == break1 || p == break2) return 0;
	} 																				// Until hit a breakpoint or HLT.
}

// *******************************************************************************************************************************
//												Load a binary file into RAM
// *******************************************************************************************************************************

void CPULoadBinary(char *fileName) {
	FILE *f = fopen(fileName,"rb");
	fread(memory,4096,1,f);
	fclose(f);
}

// *******************************************************************************************************************************
//												Gets a pointer to RAM memory
// *******************************************************************************************************************************
	
WORD16 CPURead(WORD16 address) {
	return memory[address];
}

// *******************************************************************************************************************************
//											Retrieve a snapshot of the processor
// *******************************************************************************************************************************

static CPUSTATUS cs;																// Status area

CPUSTATUS *CPUGetStatus(void) {
	cs.a = a;cs.p = p;cs.z = z;cs.cycles = cycles;cs.halt = halt;
	cs.ioMode = ioMode;cs.ioOpcode = ioOpcode;
	return &cs;
}
#endif
